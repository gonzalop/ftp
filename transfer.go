package ftp

import (
	"fmt"
	"io"
	"net"
	"os"
	"path"
	"path/filepath"
	"strings"

	"github.com/gonzalop/ftp/internal/ratelimit"
)

// StoreUnique uploads data from an io.Reader to a server-generated unique file.
// Returns the filename generated by the server.
// The transfer is performed in binary mode (TYPE I).
func (c *Client) StoreUnique(r io.Reader) (string, error) {
	// Set binary mode
	if err := c.Type("I"); err != nil {
		return "", fmt.Errorf("failed to set binary mode: %w", err)
	}

	// Open data connection and send STOU command
	resp, dataConn, err := c.cmdDataConnFrom("STOU")
	if err != nil {
		return "", err
	}

	// The filename is in the response message (150 FILE: <name>)
	// Standard response format for STOU 150 is "FILE: %s"
	msg := resp.Message
	var filename string
	if strings.HasPrefix(msg, "FILE: ") {
		filename = strings.TrimPrefix(msg, "FILE: ")
	} else {
		filename = msg // Best effort
	}

	// Apply bandwidth limiting if configured
	limiter := ratelimit.New(c.bandwidthLimit)
	limitedReader := ratelimit.NewReader(r, limiter)

	// Copy data to the connection
	_, copyErr := copyWithPooledBuffer(dataConn, limitedReader)

	// Always finish the data connection (close and read response)
	finishErr := c.finishDataConn(dataConn)

	// Return the first error that occurred
	if copyErr != nil {
		return "", fmt.Errorf("upload failed: %w", copyErr)
	}
	if finishErr != nil {
		return "", finishErr
	}

	return filename, nil
}

// Store uploads data from an io.Reader to the remote path.
// The transfer is performed in binary mode (TYPE I).
//
// Example:
//
//	file, err := os.Open("local.txt")
//	if err != nil {
//	    return err
//	}
//	defer file.Close()
//
//	err = client.Store("remote.txt", file)
func (c *Client) Store(remotePath string, r io.Reader) error {
	// Set binary mode
	if err := c.Type("I"); err != nil {
		return fmt.Errorf("failed to set binary mode: %w", err)
	}

	// Open data connection and send STOR command
	_, dataConn, err := c.cmdDataConnFrom("STOR", remotePath)
	if err != nil {
		return err
	}

	// Apply bandwidth limiting if configured
	limiter := ratelimit.New(c.bandwidthLimit)
	limitedReader := ratelimit.NewReader(r, limiter)

	// Copy data to the connection
	_, copyErr := copyWithPooledBuffer(dataConn, limitedReader)

	// Always finish the data connection (close and read response)
	finishErr := c.finishDataConn(dataConn)

	// Return the first error that occurred
	if copyErr != nil {
		return fmt.Errorf("upload failed: %w", copyErr)
	}
	if finishErr != nil {
		return finishErr
	}

	return nil
}

// StoreFrom uploads a local file to the remote path.
// This is a convenience wrapper around Store.
func (c *Client) StoreFrom(remotePath, localPath string) error {
	file, err := os.Open(localPath)
	if err != nil {
		return fmt.Errorf("failed to open local file: %w", err)
	}
	defer file.Close()

	return c.Store(remotePath, file)
}

// Retrieve downloads data from the remote path to an io.Writer.
// The transfer is performed in binary mode (TYPE I).
//
// Example:
//
//	file, err := os.Create("local.txt")
//	if err != nil {
//	    return err
//	}
//	defer file.Close()
//
//	err = client.Retrieve("remote.txt", file)
func (c *Client) Retrieve(remotePath string, w io.Writer) error {
	// Set binary mode
	if err := c.Type("I"); err != nil {
		return fmt.Errorf("failed to set binary mode: %w", err)
	}

	// Open data connection and send RETR command
	_, dataConn, err := c.cmdDataConnFrom("RETR", remotePath)
	if err != nil {
		return err
	}

	// Apply bandwidth limiting if configured
	limiter := ratelimit.New(c.bandwidthLimit)
	limitedReader := ratelimit.NewReader(dataConn, limiter)

	// Copy data from the connection
	_, copyErr := copyWithPooledBuffer(w, limitedReader)

	// Always finish the data connection (close and read response)
	finishErr := c.finishDataConn(dataConn)

	// Return the first error that occurred
	if copyErr != nil {
		return fmt.Errorf("download failed: %w", copyErr)
	}
	if finishErr != nil {
		return finishErr
	}

	return nil
}

// RetrieveTo downloads a remote file to a local path.
// This is a convenience wrapper around Retrieve.
func (c *Client) RetrieveTo(remotePath, localPath string) error {
	file, err := os.Create(localPath)
	if err != nil {
		return fmt.Errorf("failed to create local file: %w", err)
	}
	defer file.Close()

	return c.Retrieve(remotePath, file)
}

// Append appends data from an io.Reader to the remote path.
// If the file doesn't exist, it will be created.
// The transfer is performed in binary mode (TYPE I).
func (c *Client) Append(remotePath string, r io.Reader) error {
	// Set binary mode
	if err := c.Type("I"); err != nil {
		return fmt.Errorf("failed to set binary mode: %w", err)
	}

	// Open data connection and send APPE command
	_, dataConn, err := c.cmdDataConnFrom("APPE", remotePath)
	if err != nil {
		return err
	}

	// Apply bandwidth limiting if configured
	limiter := ratelimit.New(c.bandwidthLimit)
	limitedReader := ratelimit.NewReader(r, limiter)

	// Copy data to the connection
	_, copyErr := copyWithPooledBuffer(dataConn, limitedReader)

	// Always finish the data connection (close and read response)
	finishErr := c.finishDataConn(dataConn)

	// Return the first error that occurred
	if copyErr != nil {
		return fmt.Errorf("append failed: %w", copyErr)
	}
	if finishErr != nil {
		return finishErr
	}

	return nil
}

// RestartAt sets the restart marker for the next transfer.
// This allows resuming a transfer from a specific byte offset.
// The offset applies to the next RETR or STOR command.
// This implements RFC 3959 - The FTP REST Extension.
//
// Example:
//
//	err := client.RestartAt(1024)
//	if err != nil {
//	    log.Fatal(err)
//	}
//	err = client.Retrieve("file.bin", writer) // Resumes from byte 1024
func (c *Client) RestartAt(offset int64) error {
	resp, err := c.sendCommand("REST", fmt.Sprintf("%d", offset))
	if err != nil {
		return err
	}

	// REST should return 350 (Requested file action pending further information)
	if resp.Code != 350 {
		return &ProtocolError{
			Command:  "REST",
			Response: resp.Message,
			Code:     resp.Code,
		}
	}

	return nil
}

// RetrieveFrom downloads a file starting from the specified byte offset.
// This is useful for resuming interrupted downloads.
// The transfer is performed in binary mode (TYPE I).
//
// Example:
//
//	file, err := os.OpenFile("large.bin", os.O_WRONLY|os.O_APPEND, 0644)
//	if err != nil {
//	    log.Fatal(err)
//	}
//	defer file.Close()
//
//	info, _ := file.Stat()
//	err = client.RetrieveFrom("large.bin", file, info.Size())
func (c *Client) RetrieveFrom(remotePath string, w io.Writer, offset int64) error {
	// Set binary mode
	if err := c.Type("I"); err != nil {
		return fmt.Errorf("failed to set binary mode: %w", err)
	}

	// Set restart marker if offset > 0
	if offset > 0 {
		if err := c.RestartAt(offset); err != nil {
			return fmt.Errorf("failed to set restart marker: %w", err)
		}
	}

	// Open data connection and send RETR command
	_, dataConn, err := c.cmdDataConnFrom("RETR", remotePath)
	if err != nil {
		return err
	}

	// Apply bandwidth limiting if configured
	limiter := ratelimit.New(c.bandwidthLimit)
	limitedReader := ratelimit.NewReader(dataConn, limiter)

	// Copy data from the connection
	_, copyErr := copyWithPooledBuffer(w, limitedReader)

	// Always finish the data connection (close and read response)
	finishErr := c.finishDataConn(dataConn)

	// Return the first error that occurred
	if copyErr != nil {
		return fmt.Errorf("download failed: %w", copyErr)
	}
	if finishErr != nil {
		return finishErr
	}

	return nil
}

// StoreAt uploads a file starting from the specified byte offset.
// This allows resuming an interrupted upload by appending to an existing file.
// The transfer is performed in binary mode (TYPE I).
//
// Note: This uses APPE (append) mode when offset > 0, which may not be supported
// by all servers for resume functionality. For true resume support, the server
// must support REST+STOR, which is less common.
func (c *Client) StoreAt(remotePath string, r io.Reader, offset int64) error {
	// Set binary mode
	if err := c.Type("I"); err != nil {
		return fmt.Errorf("failed to set binary mode: %w", err)
	}

	var dataConn net.Conn
	var err error

	if offset > 0 {
		// Use APPE for resume (append mode)
		_, dataConn, err = c.cmdDataConnFrom("APPE", remotePath)
	} else {
		// Normal STOR
		_, dataConn, err = c.cmdDataConnFrom("STOR", remotePath)
	}

	if err != nil {
		return err
	}

	// Apply bandwidth limiting if configured
	limiter := ratelimit.New(c.bandwidthLimit)
	limitedReader := ratelimit.NewReader(r, limiter)

	// Copy data to the connection
	_, copyErr := copyWithPooledBuffer(dataConn, limitedReader)

	// Always finish the data connection (close and read response)
	finishErr := c.finishDataConn(dataConn)

	// Return the first error that occurred
	if copyErr != nil {
		return fmt.Errorf("upload failed: %w", copyErr)
	}
	if finishErr != nil {
		return finishErr
	}

	return nil
}

// UploadDir uploads a local directory to the remote server recursively.
// It creates the remote directory structure if needed.
//
// Example:
//
//	err := client.UploadDir("local_files", "/remote/files")
func (c *Client) UploadDir(localDir, remoteDir string) error {
	localDir = filepath.Clean(localDir)

	// Walk the local directory
	return filepath.Walk(localDir, func(pathStr string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		// Skip symlinks for safety
		// We don't want to accidentally upload files outside the directory
		// that are linked to.
		if info.Mode()&os.ModeSymlink != 0 {
			return nil
		}

		// Calculate relative path from localDir
		relPath, err := filepath.Rel(localDir, pathStr)
		if err != nil {
			return err
		}

		if relPath == "." {
			// Don't recreate the root remoteDir, it is assumed to be the target
			// But maybe we should create it if it doesn't exist?
			// Let's try to create it just in case, but ignore error
			_ = c.MakeDir(remoteDir)
			return nil
		}

		// Construct remote path using forward slashes
		// On Windows relPath might use backslashes, so we convert them
		remotePath := path.Join(remoteDir, filepath.ToSlash(relPath))

		if info.IsDir() {
			// Create remote directory
			// We try to create it. If it fails, we assume it might already exist.
			// Ideally we would check the error code (550) but for now we'll proceed.
			// If we really can't create it and it doesn't exist, file uploads inside will fail.
			_ = c.MakeDir(remotePath)
		} else {
			// Upload file
			file, err := os.Open(pathStr)
			if err != nil {
				return err
			}
			defer file.Close()

			if err := c.Store(remotePath, file); err != nil {
				return err
			}
		}
		return nil
	})
}

// DownloadDir downloads a remote directory to the local filesystem recursively.
// It creates the local directory structure if needed.
//
// Example:
//
//	err := client.DownloadDir("/remote/files", "local_backup")
func (c *Client) DownloadDir(remoteDir, localDir string) error {
	// Ensure local root dir exists
	if err := os.MkdirAll(localDir, 0755); err != nil {
		return err
	}

	// Walk remote directory
	return c.Walk(remoteDir, func(pathStr string, info *Entry, err error) error {
		if err != nil {
			return err
		}

		// Calculate relative path from remoteDir
		// path.Rel does not exist in standard library.
		// Since we are walking, we know pathStr starts with remoteDir.
		if !strings.HasPrefix(pathStr, remoteDir) {
			return fmt.Errorf("invalid path in walk: %s (expected prefix %s)", pathStr, remoteDir)
		}

		relPath := strings.TrimPrefix(pathStr, remoteDir)
		relPath = strings.TrimPrefix(relPath, "/")

		if relPath == "" {
			return nil
		}

		localPath := filepath.Join(localDir, filepath.FromSlash(relPath))

		if info.Type == "dir" {
			// Create local directory
			if err := os.MkdirAll(localPath, 0755); err != nil {
				return err
			}
		} else {
			// File
			// Ensure parent dir exists (should already match "dir" case, but just to be safe)
			if err := os.MkdirAll(filepath.Dir(localPath), 0755); err != nil {
				return err
			}

			file, err := os.Create(localPath)
			if err != nil {
				return err
			}
			defer file.Close()

			if err := c.Retrieve(pathStr, file); err != nil {
				return err
			}
		}
		return nil
	})
}
